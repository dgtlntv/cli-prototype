<!DOCTYPE html>
<html>
    <head>
        <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
        <link href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet" />
        <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
        <style>
            @import url("https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@400;700&display=swap");

            html,
            body {
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #330f25;
            }
            #terminal {
                height: 100%;
                width: 100%;
            }
            .xterm-viewport {
                overflow-y: auto;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .xterm-viewport::-webkit-scrollbar {
                width: 0;
                height: 0;
            }
            .xterm {
                padding: 20px;
                font-family: "Ubuntu Mono", monospace;
            }
            .xterm-screen {
                width: 100% !important;
            }
        </style>
    </head>
    <body>
        <div id="terminal"></div>
        <script>
            let customCommands = {}
            let term
            let welcomeMessage = "Welcome to the Ubuntu Terminal!\nType 'help' to see a list of available commands."
            let welcomeColor = "white"

            fetch("commands.json")
                .then((response) => response.json())
                .then((data) => {
                    if (data.welcome) {
                        welcomeMessage = data.welcome.message || welcomeMessage
                        welcomeColor = data.welcome.color || welcomeColor
                    }
                    customCommands = data.commands || {}
                    initializeTerminal()
                })
                .catch((error) => {
                    console.error("Error loading commands:", error)
                    initializeTerminal()
                })

            function initializeTerminal() {
                term = new Terminal({
                    cursorBlink: true,
                    fontSize: 18,
                    fontFamily: '"Ubuntu Mono", monospace',
                    fontWeight: 400,
                    theme: {
                        background: "#330F25",
                        foreground: "#ffffff",
                        cursor: "#ffffff",
                        selection: "rgba(255, 255, 255, 0.3)",
                        black: "#2e3436",
                        red: "#cc0000",
                        green: "#00975F",
                        yellow: "#c4a000",
                        blue: "#00407C",
                        magenta: "#75507b",
                        cyan: "#06989a",
                        white: "#d3d7cf",
                    },
                })

                const fitAddon = new FitAddon.FitAddon()
                term.loadAddon(fitAddon)
                term.open(document.getElementById("terminal"))

                term.attachCustomKeyEventHandler((event) => {
                    if ((event.ctrlKey || event.metaKey) && event.code === "KeyV" && event.type === "keydown") {
                        navigator.clipboard.readText().then((text) => {
                            term.write(text)
                        })
                        return false
                    }

                    if ((event.ctrlKey || event.metaKey) && event.code === "KeyC" && event.type === "keydown") {
                        const selection = term.getSelection()
                        if (selection) {
                            navigator.clipboard.writeText(selection)
                            return false
                        }
                    }

                    return true
                })

                fitAddon.fit()

                window.addEventListener("resize", () => fitAddon.fit())

                let input = ""
                let commandHistory = []
                let historyIndex = -1
                let cursorPosition = 0

                term.onKey(({ key, domEvent }) => {
                    const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey

                    if (domEvent.keyCode === 13) {
                        // Enter key
                        term.writeln("")
                        if (input.trim() !== "") {
                            commandHistory.unshift(input)
                            historyIndex = -1
                        }
                        handleCommand(input)
                        input = ""
                        cursorPosition = 0
                    } else if (domEvent.keyCode === 8) {
                        // Backspace
                        if (cursorPosition > 0) {
                            input = input.slice(0, cursorPosition - 1) + input.slice(cursorPosition)
                            cursorPosition--
                            term.write("\b \b")
                            term.write(input.slice(cursorPosition))
                            term.write("\x1b[K")
                            term.write("\x1b[" + (input.length - cursorPosition) + "D")
                        }
                    } else if (domEvent.keyCode === 37) {
                        // Left arrow
                        if (cursorPosition > 0) {
                            cursorPosition--
                            term.write(key)
                        }
                    } else if (domEvent.keyCode === 39) {
                        // Right arrow
                        if (cursorPosition < input.length) {
                            cursorPosition++
                            term.write(key)
                        }
                    } else if (domEvent.keyCode === 38) {
                        // Up arrow
                        if (historyIndex < commandHistory.length - 1) {
                            historyIndex++
                            input = commandHistory[historyIndex]
                            term.write(
                                "\x1b[2K\r\x1b[1;32muser@ubuntu\x1b[0m:\x1b[1;34m~\x1b[0m\x1b[37m$ \x1b[0m" + input
                            )
                            cursorPosition = input.length
                        }
                    } else if (domEvent.keyCode === 40) {
                        // Down arrow
                        if (historyIndex > -1) {
                            historyIndex--
                            if (historyIndex === -1) {
                                input = ""
                            } else {
                                input = commandHistory[historyIndex]
                            }
                            term.write(
                                "\x1b[2K\r\x1b[1;32muser@ubuntu\x1b[0m:\x1b[1;34m~\x1b[0m\x1b[37m$ \x1b[0m" + input
                            )
                            cursorPosition = input.length
                        }
                    } else if (printable) {
                        input = input.slice(0, cursorPosition) + key + input.slice(cursorPosition)
                        cursorPosition++
                        term.write(key)
                        if (cursorPosition < input.length) {
                            term.write(input.slice(cursorPosition))
                            term.write("\x1b[" + (input.length - cursorPosition) + "D")
                        }
                    }
                })

                writeColoredText(welcomeMessage, welcomeColor)
                writePrompt()
            }

            async function handleCommand(cmd) {
                const args = cmd.trim().split(/\s+/)
                const command = args[0].toLowerCase()
                const restArgs = args.slice(1)

                if (command === "clear") {
                    term.clear()
                    term.reset()
                    term.write("\x1b[H")
                    writePrompt()
                } else if (command === "help") {
                    showGeneralHelp()
                } else {
                    await executeCommand(command, restArgs)
                }
            }

            function showGeneralHelp() {
                term.writeln("Available commands:")
                term.writeln("  help - Show available commands")
                Object.entries(customCommands).forEach(([command, details]) => {
                    const aliases = details.aliases ? ` (${details.aliases.join(", ")})` : ""
                    term.writeln(`  ${command}${aliases} - ${details.description}`)
                })
                term.writeln("\nType '<command> --help' for more information on a specific command.")
                writePrompt()
            }

            function showCommandHelp(command) {
                const cmd = getCommand(command)
                if (cmd) {
                    term.writeln(`${command} - ${cmd.description}`)
                    if (cmd.args) {
                        term.writeln("\nArguments:")
                        cmd.args.forEach((arg) => {
                            term.writeln(`  ${arg.name}: ${arg.description}`)
                        })
                    }
                    if (cmd.flags) {
                        term.writeln("\nFlags:")
                        Object.entries(cmd.flags).forEach(([flag, details]) => {
                            const aliases = details.aliases ? ` (${details.aliases.join(", ")})` : ""
                            term.writeln(`  ${flag}${aliases}: ${details.description}`)
                        })
                    }
                    if (cmd.subcommands) {
                        term.writeln("\nSubcommands:")
                        Object.entries(cmd.subcommands).forEach(([subcommand, details]) => {
                            term.writeln(`  ${subcommand} - ${details.description}`)
                        })
                    }
                } else {
                    term.writeln(`No help available for '${command}'.`)
                }
            }

            function getCommand(command) {
                return (
                    customCommands[command] ||
                    Object.values(customCommands).find((cmd) => cmd.aliases && cmd.aliases.includes(command))
                )
            }

            async function executeCommand(command, args) {
                const cmd = getCommand(command)
                if (!cmd) {
                    term.writeln(`Unknown command: ${command}`)
                    writePrompt()
                    return
                }

                const { flags, positionalArgs } = parseArgs(args, cmd)

                if (flags["--help"] || flags["-h"]) {
                    showCommandHelp(command)
                    writePrompt()
                    return
                }

                if (cmd.subcommands && positionalArgs.length > 0) {
                    const subcommand = cmd.subcommands[positionalArgs[0]]
                    if (subcommand) {
                        await executeAction(subcommand.action, flags, positionalArgs.slice(1))
                        writePrompt()
                        return
                    }
                }

                if (cmd.prompts) {
                    const promptResults = await handlePrompts(cmd.prompts)
                    Object.assign(flags, promptResults)
                }

                await executeAction(cmd.action, flags, positionalArgs)
                writePrompt()
            }

            function parseArgs(args, cmd) {
                const flags = {}
                const positionalArgs = []
                const flagAliases = createFlagAliasMap(cmd.flags)

                for (let i = 0; i < args.length; i++) {
                    const arg = args[i]
                    if (arg.startsWith("-")) {
                        const flagName = flagAliases[arg]
                        if (flagName) {
                            const flagDetails = cmd.flags[flagName]
                            if (flagDetails.requiresValue && i + 1 < args.length) {
                                flags[flagName] = args[++i]
                            } else {
                                flags[flagName] = true
                            }
                        }
                    } else {
                        positionalArgs.push(arg)
                    }
                }

                return { flags, positionalArgs }
            }

            function createFlagAliasMap(flags) {
                const aliasMap = {}
                if (!flags) return aliasMap

                Object.entries(flags).forEach(([flag, details]) => {
                    aliasMap[flag] = flag
                    if (details.aliases) {
                        details.aliases.forEach((alias) => {
                            aliasMap[alias] = flag
                        })
                    }
                })

                return aliasMap
            }

            async function handlePrompts(prompts) {
                const results = {}
                for (const prompt of prompts) {
                    term.write(`${prompt.message} `)
                    const input = await new Promise((resolve) => {
                        let inputBuffer = ""
                        term.onData((data) => {
                            if (data === "\r") {
                                term.write("\r\n")
                                resolve(inputBuffer)
                            } else if (data === "\u007F") {
                                // Backspace
                                if (inputBuffer.length > 0) {
                                    inputBuffer = inputBuffer.slice(0, -1)
                                    term.write("\b \b")
                                }
                            } else {
                                inputBuffer += data
                                if (prompt.hidden) {
                                    term.write("*")
                                } else {
                                    term.write(data)
                                }
                            }
                        })
                    })
                    results[prompt.name] = input
                }
                return results
            }

            async function executeAction(action, flags, args) {
                if (Array.isArray(action)) {
                    for (const item of action) {
                        await processActionItem(item, flags, args)
                    }
                } else if (typeof action === "object") {
                    await processActionItem(action, flags, args)
                } else if (typeof action === "string") {
                    writeColoredText(interpolate(action, { flags, args }), "white")
                    term.write("\r\n")
                }
            }

            async function processActionItem(item, flags, args) {
                if (typeof item === "string") {
                    writeColoredText(interpolate(item, { flags, args }), "white")
                    term.write("\r\n")
                } else if (typeof item === "object") {
                    if (item.if) {
                        const condition = interpolate(item.if, { flags, args })
                        if (eval(condition)) {
                            await executeAction(item.then, flags, args)
                        } else if (item.else) {
                            await executeAction(item.else, flags, args)
                        }
                    } else if (item.command) {
                        await executeCommand(item.command, [])
                    } else if (item.text) {
                        writeColoredText(interpolate(item.text, { flags, args }), item.color || "white")
                        term.write("\r\n")
                        if (item.delay) {
                            await new Promise((resolve) => setTimeout(resolve, item.delay))
                        }
                    } else if (item.type === "progressBar") {
                        await showProgressBar(item.text, item.duration)
                    } else if (item.type === "spinner") {
                        await showSpinner(item.text, item.duration)
                    }
                }
            }

            function interpolate(text, context) {
                return text.replace(/\{\{([^}]+)\}\}/g, (_, expr) => {
                    return eval(`with (context) { ${expr} }`)
                })
            }

            async function showProgressBar(text, duration) {
                const width = 20
                const frameDuration = 100
                const frames = duration / frameDuration

                for (let i = 0; i <= frames; i++) {
                    const progress = i / frames
                    const filled = Math.round(width * progress)
                    const empty = width - filled
                    const bar = `[${"=".repeat(filled)}${" ".repeat(empty)}]`
                    const percentage = Math.round(progress * 100)

                    term.write(`\r${text} ${bar} ${percentage}%`)

                    if (i < frames) {
                        await new Promise((resolve) => setTimeout(resolve, frameDuration))
                    }
                }
                term.write("\r\n")
            }

            async function showSpinner(text, duration) {
                const spinnerFrames = ["|", "/", "-", "\\"]
                const frameDuration = 100
                const frames = duration / frameDuration

                for (let i = 0; i < frames; i++) {
                    const frame = spinnerFrames[i % spinnerFrames.length]
                    term.write(`\r${text} ${frame}`)
                    await new Promise((resolve) => setTimeout(resolve, frameDuration))
                }
                term.write("\r\n")
            }

            function writePrompt() {
                term.write("\r\n\x1b[1;32muser@ubuntu\x1b[0m:\x1b[1;34m~\x1b[0m\x1b[37m$ \x1b[0m")
            }

            function writeColoredText(text, color) {
                const colorCodes = {
                    black: "\x1b[30m",
                    red: "\x1b[31m",
                    green: "\x1b[32m",
                    yellow: "\x1b[33m",
                    blue: "\x1b[34m",
                    magenta: "\x1b[35m",
                    cyan: "\x1b[36m",
                    white: "\x1b[37m",
                }
                const colorCode = color && colorCodes[color] ? colorCodes[color] : ""
                const resetCode = colorCode ? "\x1b[0m" : ""

                const lines = text.split("\n")
                for (let i = 0; i < lines.length; i++) {
                    if (i > 0) term.write("\r\n")
                    term.write(`${colorCode}${lines[i]}${resetCode}`)
                }
            }
        </script>
    </body>
</html>
